"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WebPlayer_instances, _WebPlayer_context, _WebPlayer_startNextPlaybackAt, _WebPlayer_bufferDuration, _WebPlayer_playBuffer;
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebPlayer = void 0;
const utils_1 = require("./utils");
class WebPlayer {
    /**
     * Create a new Player.
     *
     * @param options - Options for the Player.
     * @param options.bufferDuration - The duration of the audio buffer to play.
     */
    constructor({ bufferDuration }) {
        _WebPlayer_instances.add(this);
        _WebPlayer_context.set(this, null);
        _WebPlayer_startNextPlaybackAt.set(this, 0);
        _WebPlayer_bufferDuration.set(this, void 0);
        __classPrivateFieldSet(this, _WebPlayer_bufferDuration, bufferDuration, "f");
    }
    /**
     * Play audio from a source.
     *
     * @param source The source to play audio from.
     * @returns A promise that resolves when the audio has finished playing.
     */
    play(source) {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _WebPlayer_startNextPlaybackAt, 0, "f");
            __classPrivateFieldSet(this, _WebPlayer_context, new AudioContext({ sampleRate: source.sampleRate }), "f");
            const buffer = new Float32Array(source.durationToSampleCount(__classPrivateFieldGet(this, _WebPlayer_bufferDuration, "f")));
            const plays = [];
            while (true) {
                const read = yield source.read(buffer);
                // If we've reached the end of the source, then read < buffer.length.
                // In that case, we don't want to play the entire buffer, as that
                // will cause repeated audio.
                // So we set the buffer to the correct length.
                const playableAudio = buffer.subarray(0, read);
                plays.push(__classPrivateFieldGet(this, _WebPlayer_instances, "m", _WebPlayer_playBuffer).call(this, playableAudio, source.sampleRate));
                if (read < buffer.length) {
                    // No more audio to read.
                    break;
                }
            }
            yield Promise.all(plays);
        });
    }
    /**
     * Pause the audio.
     *
     * @returns A promise that resolves when the audio has been paused.
     */
    pause() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
                throw new Error("AudioContext not initialized.");
            }
            yield __classPrivateFieldGet(this, _WebPlayer_context, "f").suspend();
        });
    }
    /**
     * Resume the audio.
     *
     * @returns A promise that resolves when the audio has been resumed.
     */
    resume() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
                throw new Error("AudioContext not initialized.");
            }
            yield __classPrivateFieldGet(this, _WebPlayer_context, "f").resume();
        });
    }
    /**
     * Toggle the audio.
     *
     * @returns A promise that resolves when the audio has been toggled.
     */
    toggle() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
                throw new Error("AudioContext not initialized.");
            }
            if (__classPrivateFieldGet(this, _WebPlayer_context, "f").state === "running") {
                yield this.pause();
            }
            else {
                yield this.resume();
            }
        });
    }
    /**
     * Stop the audio.
     *
     * @returns A promise that resolves when the audio has been stopped.
     */
    stop() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
                throw new Error("AudioContext not initialized.");
            }
            yield ((_a = __classPrivateFieldGet(this, _WebPlayer_context, "f")) === null || _a === void 0 ? void 0 : _a.close());
        });
    }
}
exports.WebPlayer = WebPlayer;
_WebPlayer_context = new WeakMap(), _WebPlayer_startNextPlaybackAt = new WeakMap(), _WebPlayer_bufferDuration = new WeakMap(), _WebPlayer_instances = new WeakSet(), _WebPlayer_playBuffer = function _WebPlayer_playBuffer(buf, sampleRate) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!__classPrivateFieldGet(this, _WebPlayer_context, "f")) {
            throw new Error("AudioContext not initialized.");
        }
        if (buf.length === 0) {
            return;
        }
        const startAt = __classPrivateFieldGet(this, _WebPlayer_startNextPlaybackAt, "f");
        const duration = buf.length / sampleRate;
        __classPrivateFieldSet(this, _WebPlayer_startNextPlaybackAt, duration + Math.max(__classPrivateFieldGet(this, _WebPlayer_context, "f").currentTime, __classPrivateFieldGet(this, _WebPlayer_startNextPlaybackAt, "f")), "f");
        yield (0, utils_1.playAudioBuffer)(buf, __classPrivateFieldGet(this, _WebPlayer_context, "f"), startAt, sampleRate);
    });
};
