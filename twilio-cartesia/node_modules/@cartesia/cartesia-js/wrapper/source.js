"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Source_instances, _Source_emitter, _Source_buffer, _Source_readIndex, _Source_writeIndex, _Source_closed, _Source_sampleRate, _Source_encoding, _Source_container, _Source_createBuffer;
Object.defineProperty(exports, "__esModule", { value: true });
const emittery_1 = __importDefault(require("emittery"));
const utils_1 = require("./utils");
class Source {
    /**
     * Create a new Source.
     *
     * @param options - Options for the Source.
     * @param options.sampleRate - The sample rate of the audio.
     */
    constructor({ sampleRate, encoding, container }) {
        _Source_instances.add(this);
        _Source_emitter.set(this, new emittery_1.default());
        _Source_buffer.set(this, void 0);
        _Source_readIndex.set(this, 0);
        _Source_writeIndex.set(this, 0);
        _Source_closed.set(this, false);
        _Source_sampleRate.set(this, void 0);
        _Source_encoding.set(this, void 0);
        _Source_container.set(this, void 0);
        this.on = __classPrivateFieldGet(this, _Source_emitter, "f").on.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.once = __classPrivateFieldGet(this, _Source_emitter, "f").once.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.events = __classPrivateFieldGet(this, _Source_emitter, "f").events.bind(__classPrivateFieldGet(this, _Source_emitter, "f"));
        this.off = __classPrivateFieldGet(this, _Source_emitter, "f").off.bind(__classPrivateFieldGet(this, _Source_emitter, "f").off);
        __classPrivateFieldSet(this, _Source_sampleRate, sampleRate, "f");
        __classPrivateFieldSet(this, _Source_encoding, encoding, "f");
        __classPrivateFieldSet(this, _Source_container, container, "f");
        __classPrivateFieldSet(this, _Source_buffer, __classPrivateFieldGet(this, _Source_instances, "m", _Source_createBuffer).call(this, 1024), "f"); // Initial size, can be adjusted
    }
    get sampleRate() {
        return __classPrivateFieldGet(this, _Source_sampleRate, "f");
    }
    get encoding() {
        return __classPrivateFieldGet(this, _Source_encoding, "f");
    }
    get container() {
        return __classPrivateFieldGet(this, _Source_container, "f");
    }
    /**
     * Append audio to the buffer.
     *
     * @param src The audio to append.
     */
    enqueue(src) {
        return __awaiter(this, void 0, void 0, function* () {
            const requiredCapacity = __classPrivateFieldGet(this, _Source_writeIndex, "f") + src.length;
            // Resize buffer if necessary
            if (requiredCapacity > __classPrivateFieldGet(this, _Source_buffer, "f").length) {
                let newCapacity = __classPrivateFieldGet(this, _Source_buffer, "f").length;
                while (newCapacity < requiredCapacity) {
                    newCapacity *= 2; // Double the buffer size
                }
                const newBuffer = __classPrivateFieldGet(this, _Source_instances, "m", _Source_createBuffer).call(this, newCapacity);
                newBuffer.set(__classPrivateFieldGet(this, _Source_buffer, "f"));
                __classPrivateFieldSet(this, _Source_buffer, newBuffer, "f");
            }
            // Append the audio to the buffer.
            __classPrivateFieldGet(this, _Source_buffer, "f").set(src, __classPrivateFieldGet(this, _Source_writeIndex, "f"));
            __classPrivateFieldSet(this, _Source_writeIndex, __classPrivateFieldGet(this, _Source_writeIndex, "f") + src.length, "f");
            yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("enqueue");
        });
    }
    /**
     * Read audio from the buffer.
     *
     * @param dst The buffer to read the audio into.
     * @returns The number of samples read. If the source is closed, this will be
     * less than the length of the provided buffer.
     */
    read(dst) {
        return __awaiter(this, void 0, void 0, function* () {
            // Read the buffer into the provided buffer.
            const targetReadIndex = __classPrivateFieldGet(this, _Source_readIndex, "f") + dst.length;
            while (!__classPrivateFieldGet(this, _Source_closed, "f") && targetReadIndex > __classPrivateFieldGet(this, _Source_writeIndex, "f")) {
                // Wait for more audio to be enqueued.
                yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("wait");
                yield Promise.race([__classPrivateFieldGet(this, _Source_emitter, "f").once("enqueue"), __classPrivateFieldGet(this, _Source_emitter, "f").once("close")]);
                yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("read");
            }
            const read = Math.min(dst.length, __classPrivateFieldGet(this, _Source_writeIndex, "f") - __classPrivateFieldGet(this, _Source_readIndex, "f"));
            dst.set(__classPrivateFieldGet(this, _Source_buffer, "f").subarray(__classPrivateFieldGet(this, _Source_readIndex, "f"), __classPrivateFieldGet(this, _Source_readIndex, "f") + read));
            __classPrivateFieldSet(this, _Source_readIndex, __classPrivateFieldGet(this, _Source_readIndex, "f") + read, "f");
            return read;
        });
    }
    /**
     * Seek in the buffer.
     *
     * @param offset The offset to seek to.
     * @param whence The position to seek from.
     * @returns The new position in the buffer.
     * @throws {Error} If the seek is invalid.
     */
    seek(offset, whence) {
        return __awaiter(this, void 0, void 0, function* () {
            let position = __classPrivateFieldGet(this, _Source_readIndex, "f");
            switch (whence) {
                case "start":
                    position = offset;
                    break;
                case "current":
                    position += offset;
                    break;
                case "end":
                    position = __classPrivateFieldGet(this, _Source_writeIndex, "f") + offset;
                    break;
                default:
                    throw new Error(`Invalid seek mode: ${whence}`);
            }
            if (position < 0 || position > __classPrivateFieldGet(this, _Source_writeIndex, "f")) {
                throw new Error("Seek out of bounds");
            }
            __classPrivateFieldSet(this, _Source_readIndex, position, "f");
            return position;
        });
    }
    /**
     * Get the number of samples in a given duration.
     *
     * @param durationSecs The duration in seconds.
     * @returns The number of samples.
     */
    durationToSampleCount(durationSecs) {
        return Math.trunc(durationSecs * __classPrivateFieldGet(this, _Source_sampleRate, "f"));
    }
    get buffer() {
        return __classPrivateFieldGet(this, _Source_buffer, "f");
    }
    get readIndex() {
        return __classPrivateFieldGet(this, _Source_readIndex, "f");
    }
    get writeIndex() {
        return __classPrivateFieldGet(this, _Source_writeIndex, "f");
    }
    /**
     * Close the source. This signals that no more audio will be enqueued.
     *
     * This will emit a "close" event.
     *
     * @returns A promise that resolves when the source is closed.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _Source_closed, true, "f");
            yield __classPrivateFieldGet(this, _Source_emitter, "f").emit("close");
            __classPrivateFieldGet(this, _Source_emitter, "f").clearListeners();
        });
    }
}
exports.default = Source;
_Source_emitter = new WeakMap(), _Source_buffer = new WeakMap(), _Source_readIndex = new WeakMap(), _Source_writeIndex = new WeakMap(), _Source_closed = new WeakMap(), _Source_sampleRate = new WeakMap(), _Source_encoding = new WeakMap(), _Source_container = new WeakMap(), _Source_instances = new WeakSet(), _Source_createBuffer = function _Source_createBuffer(size) {
    const { arrayType: ArrayType } = utils_1.ENCODING_MAP[__classPrivateFieldGet(this, _Source_encoding, "f")];
    return new ArrayType(size);
};
