"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEmitteryCallbacks = exports.isComplete = exports.filterSentinel = exports.isSentinel = exports.getSentinel = exports.createMessageHandlerForContextId = exports.playAudioBuffer = exports.base64ToArray = exports.resolveOutputFormat = exports.ENCODING_MAP = void 0;
const base64_js_1 = __importDefault(require("base64-js"));
exports.ENCODING_MAP = {
    pcm_f32le: { arrayType: Float32Array, bytesPerElement: 4 },
    pcm_s16le: { arrayType: Int16Array, bytesPerElement: 2 },
    pcm_alaw: { arrayType: Uint8Array, bytesPerElement: 1 },
    pcm_mulaw: { arrayType: Uint8Array, bytesPerElement: 1 },
};
/**
 * Resolve the output format for a WebSocket request.
 *
 * @param container - The container type for the output.
 * @param encoding - The encoding of the audio.
 * @param sampleRate - The sample rate of the audio.
 * @returns The output format for the WebSocket request.
 */
function resolveOutputFormat(container, encoding, sampleRate) {
    switch (container) {
        case "wav":
            return {
                container: "wav",
                encoding,
                sampleRate,
            };
        case "raw":
            return {
                container: "raw",
                encoding,
                sampleRate,
            };
        case "mp3":
            return {
                container: "mp3",
                encoding,
                sampleRate,
                bitRate: 128,
            };
        default:
            throw new Error(`Unsupported container type: ${container}`);
    }
}
exports.resolveOutputFormat = resolveOutputFormat;
/**
 * Convert base64-encoded audio buffer(s) to a TypedArray.
 *
 * @param b64 The base64-encoded audio buffer, or an array of base64-encoded
 * audio buffers.
 * @param encoding The encoding of the audio buffer(s).
 * @returns The audio buffer(s) as a TypedArray.
 */
function base64ToArray(b64, encoding) {
    const byteArrays = filterSentinel(b64).map((b) => base64_js_1.default.toByteArray(b));
    const { arrayType: ArrayType, bytesPerElement } = exports.ENCODING_MAP[encoding];
    const totalLength = byteArrays.reduce((acc, arr) => acc + arr.length / bytesPerElement, 0);
    const result = new ArrayType(totalLength);
    let offset = 0;
    for (const arr of byteArrays) {
        const floats = new ArrayType(arr.buffer);
        result.set(floats, offset);
        offset += floats.length;
    }
    return result;
}
exports.base64ToArray = base64ToArray;
/**
 * Schedule an audio buffer to play at a given time in the passed context.
 *
 * @param floats The audio buffer to play.
 * @param context The audio context to play the buffer in.
 * @param startAt The time to start playing the buffer at.
 * @param sampleRate The sample rate of the audio.
 * @returns A promise that resolves when the audio has finished playing.
 */
function playAudioBuffer(floats, context, startAt, sampleRate) {
    const source = context.createBufferSource();
    const buffer = context.createBuffer(1, floats.length, sampleRate);
    buffer.getChannelData(0).set(floats);
    source.buffer = buffer;
    source.connect(context.destination);
    source.start(startAt);
    return new Promise((resolve) => {
        source.onended = () => {
            resolve();
        };
    });
}
exports.playAudioBuffer = playAudioBuffer;
/**
 * Unwraps a chunk of audio data from a message event and calls the
 * handler with it if the context ID matches.
 *
 * @param contextId The context ID to listen for.
 * @param handler The handler to call with the chunk of audio data.
 * @returns A message event handler.
 */
function createMessageHandlerForContextId(contextId, handler) {
    return (event) => {
        if (typeof event.data !== "string") {
            return; // Ignore non-string messages.
        }
        const message = JSON.parse(event.data);
        if (message.context_id !== contextId) {
            return; // Ignore messages for other contexts.
        }
        let chunk;
        if (message.done) {
            // Convert the done message to a sentinel value.
            chunk = getSentinel();
        }
        else if (message.type === "chunk") {
            chunk = message.data;
        }
        handler({ chunk, message: event.data, data: message });
    };
}
exports.createMessageHandlerForContextId = createMessageHandlerForContextId;
/**
 * Get a sentinel value that indicates the end of a stream.
 * @returns A sentinel value to indicate the end of a stream.
 */
function getSentinel() {
    return null;
}
exports.getSentinel = getSentinel;
/**
 * Check if a chunk is a sentinel value (i.e. null).
 *
 * @param chunk
 * @returns Whether the chunk is a sentinel value.
 */
function isSentinel(x) {
    return x === getSentinel();
}
exports.isSentinel = isSentinel;
/**
 * Filter out null values from a collection.
 *
 * @param collection The collection to filter.
 * @returns The collection with null values removed.
 */
function filterSentinel(collection) {
    return collection.filter((x) => !isSentinel(x));
}
exports.filterSentinel = filterSentinel;
/**
 * Check if an array of chunks is complete by testing if the last chunk is a sentinel
 * value (i.e. null).
 * @param chunk
 * @returns Whether the array of chunks is complete.
 */
function isComplete(chunks) {
    return isSentinel(chunks[chunks.length - 1]);
}
exports.isComplete = isComplete;
/**
 * Get user-facing emitter callbacks for an Emittery instance.
 * @param emitter The Emittery instance to get callbacks for.
 * @returns User-facing emitter callbacks.
 */
function getEmitteryCallbacks(emitter) {
    return {
        on: emitter.on.bind(emitter),
        off: emitter.off.bind(emitter),
        once: emitter.once.bind(emitter),
        events: emitter.events.bind(emitter),
    };
}
exports.getEmitteryCallbacks = getEmitteryCallbacks;
